import * as syntax from '../syntax/index.js';
import { _isBytesWrapper } from '../interfaces/bytes.js';
import * as interfaces from '../interfaces/index.js';
import { assert } from '../utils.js';
import { allowsEval, getGraphemeLength, getUtf8Length, isArray, isObject, lazy, lazyProperty, } from './utils.js';
// #__NO_SIDE_EFFECTS__
const joinIssues = (left, right) => {
    return left ? { ok: false, code: 'join', left, right } : right;
};
// #__NO_SIDE_EFFECTS__
const prependPath = (key, tree) => {
    return { ok: false, code: 'prepend', key, tree };
};
// #__NO_SIDE_EFFECTS__
export const ok = (value) => {
    return { ok: true, value };
};
// None set
export const FLAG_EMPTY = 0;
// Don't continue validation if an error is encountered
export const FLAG_ABORT_EARLY = 1 << 0;
// #region Schema runner
const cloneIssueWithPath = (issue, path) => {
    const { ok: _ok, msg: _fmt, ...clone } = issue;
    return { ...clone, path };
};
const collectIssues = (tree, path = [], issues = []) => {
    for (;;) {
        switch (tree.code) {
            case 'join': {
                collectIssues(tree.left, path.slice(), issues);
                tree = tree.right;
                continue;
            }
            case 'prepend': {
                path.push(tree.key);
                tree = tree.tree;
                continue;
            }
            default: {
                issues.push(cloneIssueWithPath(tree, path));
                return issues;
            }
        }
    }
};
const countIssues = (tree) => {
    let count = 0;
    for (;;) {
        switch (tree.code) {
            case 'join': {
                count += countIssues(tree.left);
                tree = tree.right;
                continue;
            }
            case 'prepend': {
                tree = tree.tree;
                continue;
            }
            default: {
                return count + 1;
            }
        }
    }
};
const separatedList = (list, sep) => {
    switch (list.length) {
        case 0: {
            return `nothing`;
        }
        case 1: {
            return list[0];
        }
        default: {
            return `${list.slice(0, -1).join(', ')} ${sep} ${list[list.length - 1]}`;
        }
    }
};
const formatLiteral = (value) => {
    return JSON.stringify(value);
};
const formatRangeMessage = (type, unit, min, max) => {
    let message = `expected ${type} `;
    if (min > 0) {
        if (max === min) {
            message += `${min}`;
        }
        else if (max !== Infinity) {
            message += `between ${min} and ${max}`;
        }
        else {
            message += `at least ${min}`;
        }
    }
    else {
        message += `at most ${max}`;
    }
    message += ` ${unit}(s)`;
    return message;
};
const formatIssueTree = (tree) => {
    let path = '';
    let count = 0;
    for (;;) {
        switch (tree.code) {
            case 'join': {
                count += countIssues(tree.right);
                tree = tree.left;
                continue;
            }
            case 'prepend': {
                path += `.${tree.key}`;
                tree = tree.tree;
                continue;
            }
        }
        break;
    }
    const message = tree.msg();
    let msg = `${tree.code} at ${path || '.'} (${message})`;
    if (count > 0) {
        msg += ` (+${count} other issue(s))`;
    }
    return msg;
};
export class ValidationError extends Error {
    name = 'ValidationError';
    #issueTree;
    constructor(issueTree) {
        super();
        this.#issueTree = issueTree;
    }
    get message() {
        return formatIssueTree(this.#issueTree);
    }
    get issues() {
        return collectIssues(this.#issueTree);
    }
}
class ErrImpl {
    ok = false;
    #issueTree;
    constructor(issueTree) {
        this.#issueTree = issueTree;
    }
    get message() {
        return formatIssueTree(this.#issueTree);
    }
    get issues() {
        return collectIssues(this.#issueTree);
    }
    throw() {
        throw new ValidationError(this.#issueTree);
    }
}
// #__NO_SIDE_EFFECTS__
export const is = (schema, input) => {
    const r = schema['~run'](input, FLAG_ABORT_EARLY);
    return r === undefined || r.ok;
};
// #__NO_SIDE_EFFECTS__
export const safeParse = (schema, input) => {
    const r = schema['~run'](input, FLAG_EMPTY);
    if (r === undefined) {
        return ok(input);
    }
    if (r.ok) {
        return r;
    }
    return new ErrImpl(r);
};
export const parse = (schema, input) => {
    const r = schema['~run'](input, FLAG_EMPTY);
    if (r === undefined) {
        return input;
    }
    if (r.ok) {
        return r.value;
    }
    throw new ValidationError(r);
};
// #region Standard Schema support
const collectStandardIssues = (tree, path = [], issues = []) => {
    for (;;) {
        switch (tree.code) {
            case 'join': {
                collectStandardIssues(tree.left, path.slice(), issues);
                tree = tree.right;
                continue;
            }
            case 'prepend': {
                path.push(tree.key);
                tree = tree.tree;
                continue;
            }
            default: {
                issues.push({ message: tree.msg(), path: path.length > 0 ? path : undefined });
                return issues;
            }
        }
    }
};
const toStandardSchema = (schema) => {
    return {
        version: 1,
        vendor: '@atcute/lexicons',
        validate(value) {
            const r = schema['~run'](value, FLAG_EMPTY);
            if (r === undefined) {
                return { value: value };
            }
            if (r.ok) {
                return { value: r.value };
            }
            return { issues: collectStandardIssues(r) };
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const constrain = (base, constraints) => {
    const len = constraints.length;
    return {
        ...base,
        constraints: constraints,
        '~run'(input, flags) {
            let result = base['~run'](input, flags);
            let current;
            if (result === undefined) {
                current = input;
            }
            else if (result.ok) {
                current = result.value;
            }
            else {
                return result;
            }
            for (let idx = 0; idx < len; idx++) {
                const r = constraints[idx]['~run'](current, flags);
                if (r !== undefined) {
                    if (r.ok) {
                        current = r.value;
                        if (result === undefined || result.ok) {
                            result = r;
                        }
                    }
                    else {
                        if (flags & FLAG_ABORT_EARLY) {
                            return r;
                        }
                        else if (result === undefined || result.ok) {
                            result = r;
                        }
                        else {
                            result = joinIssues(result, r);
                        }
                    }
                }
            }
            return result;
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const literal = (value) => {
    const issue = {
        ok: false,
        code: 'invalid_literal',
        expected: [value],
        msg() {
            return `expected ${formatLiteral(value)}`;
        },
    };
    return {
        kind: 'schema',
        type: 'literal',
        expected: value,
        '~run'(input, _flags) {
            if (input !== value) {
                return issue;
            }
            return undefined;
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const literalEnum = (values) => {
    const issue = {
        ok: false,
        code: 'invalid_literal',
        expected: values,
        msg() {
            return `expected ${separatedList(values.map(formatLiteral), 'or')}`;
        },
    };
    return {
        kind: 'schema',
        type: 'literal_enum',
        expected: values,
        '~run'(input, _flags) {
            if (!values.includes(input)) {
                return issue;
            }
            return undefined;
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
};
const ISSUE_TYPE_BOOLEAN = {
    ok: false,
    code: 'invalid_type',
    expected: 'boolean',
    msg() {
        return `expected boolean`;
    },
};
const BOOLEAN_SCHEMA = {
    kind: 'schema',
    type: 'boolean',
    '~run'(input, _flags) {
        if (typeof input !== 'boolean') {
            return ISSUE_TYPE_BOOLEAN;
        }
        return undefined;
    },
    get '~standard'() {
        return lazyProperty(this, '~standard', toStandardSchema(this));
    },
};
// #__NO_SIDE_EFFECTS__
export const boolean = () => {
    return BOOLEAN_SCHEMA;
};
const ISSUE_TYPE_INTEGER = {
    ok: false,
    code: 'invalid_type',
    expected: 'integer',
    msg() {
        return `expected integer`;
    },
};
const INTEGER_SCHEMA = {
    kind: 'schema',
    type: 'integer',
    '~run'(input, _flags) {
        if (typeof input !== 'number') {
            return ISSUE_TYPE_INTEGER;
        }
        if (input < 0 || !Number.isSafeInteger(input)) {
            return ISSUE_TYPE_INTEGER;
        }
        return undefined;
    },
    get '~standard'() {
        return lazyProperty(this, '~standard', toStandardSchema(this));
    },
};
// #__NO_SIDE_EFFECTS__
export const integer = () => {
    return INTEGER_SCHEMA;
};
// #__NO_SIDE_EFFECTS__
export const integerRange = (min, max = Infinity) => {
    const issue = {
        ok: false,
        code: 'invalid_integer_range',
        min: min,
        max: max,
        msg() {
            let message = `expected an integer `;
            if (min > 0) {
                if (max === min) {
                    message += `of exactly ${min}`;
                }
                else if (max !== Infinity) {
                    message += `between ${min} and ${max}`;
                }
                else {
                    message += `of at least ${min}`;
                }
            }
            else {
                message += `of at most ${max}`;
            }
            return message;
        },
    };
    return {
        kind: 'constraint',
        type: 'integer_range',
        min: min,
        max: max,
        '~run'(input, _flags) {
            if (input < min) {
                return issue;
            }
            if (input > max) {
                return issue;
            }
            return undefined;
        },
    };
};
const ISSUE_TYPE_STRING = {
    ok: false,
    code: 'invalid_type',
    expected: 'string',
    msg() {
        return `expected string`;
    },
};
const STRING_SINGLETON = {
    kind: 'schema',
    type: 'string',
    format: null,
    '~run'(input, _flags) {
        if (typeof input !== 'string') {
            return ISSUE_TYPE_STRING;
        }
        return undefined;
    },
    get '~standard'() {
        return lazyProperty(this, '~standard', toStandardSchema(this));
    },
};
// #__NO_SIDE_EFFECTS__
export const string = () => {
    return STRING_SINGLETON;
};
// #__NO_SIDE_EFFECTS__
const _formattedString = (format, validate) => {
    const issue = {
        ok: false,
        code: 'invalid_string_format',
        expected: format,
        msg() {
            return `expected a ${format} formatted string`;
        },
    };
    const schema = {
        kind: 'schema',
        type: 'string',
        format: format,
        '~run'(input, _flags) {
            if (typeof input !== 'string') {
                return ISSUE_TYPE_STRING;
            }
            if (!validate(input)) {
                return issue;
            }
            return undefined;
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
    return () => schema;
};
// prettier-ignore
export const actorIdentifierString = /*#__PURE__*/ _formattedString('at-identifier', syntax.isActorIdentifier);
export const resourceUriString = /*#__PURE__*/ _formattedString('at-uri', syntax.isResourceUri);
export const cidString = /*#__PURE__*/ _formattedString('cid', syntax.isCid);
export const datetimeString = /*#__PURE__*/ _formattedString('datetime', syntax.isDatetime);
export const didString = /*#__PURE__*/ _formattedString('did', syntax.isDid);
export const handleString = /*#__PURE__*/ _formattedString('handle', syntax.isHandle);
export const languageCodeString = /*#__PURE__*/ _formattedString('language', syntax.isLanguageCode);
export const nsidString = /*#__PURE__*/ _formattedString('nsid', syntax.isNsid);
export const recordKeyString = /*#__PURE__*/ _formattedString('record-key', syntax.isRecordKey);
export const tidString = /*#__PURE__*/ _formattedString('tid', syntax.isTid);
export const genericUriString = /*#__PURE__*/ _formattedString('uri', syntax.isGenericUri);
// #__NO_SIDE_EFFECTS__
export const stringLength = (minLength, maxLength = Infinity) => {
    const issue = {
        ok: false,
        code: 'invalid_string_length',
        minLength: minLength,
        maxLength: maxLength,
        msg() {
            return formatRangeMessage('a string', 'character', minLength, maxLength);
        },
    };
    return {
        kind: 'constraint',
        type: 'string_length',
        minLength: minLength,
        maxLength: maxLength,
        '~run'(input, _flags) {
            // UTF-8 conversion can be expensive, so we're going to do some safe naive
            // checks where we assume an upper-bound of the UTF-16 to UTF-8 conversion
            const utf16Len = input.length;
            const maybeUtf8Len = utf16Len * 3;
            // fail early if estimated upper bound is too small
            if (maybeUtf8Len < minLength) {
                return issue;
            }
            // skip calculation if UTF-16 length already satisfies both constraints
            if (utf16Len >= minLength && maybeUtf8Len <= maxLength) {
                return undefined;
            }
            const utf8Len = getUtf8Length(input);
            if (utf8Len < minLength) {
                return issue;
            }
            if (utf8Len > maxLength) {
                return issue;
            }
            return undefined;
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const stringGraphemes = (minGraphemes, maxGraphemes = Infinity) => {
    const issue = {
        ok: false,
        code: 'invalid_string_graphemes',
        minGraphemes: minGraphemes,
        maxGraphemes: maxGraphemes,
        msg() {
            return formatRangeMessage('a string', 'grapheme', minGraphemes, maxGraphemes);
        },
    };
    return {
        kind: 'constraint',
        type: 'string_graphemes',
        minGraphemes: minGraphemes,
        maxGraphemes: maxGraphemes,
        '~run'(input, _flags) {
            // grapheme conversion is expensive, so we're going to do some safe naive
            // checks where we assume 1 UTF-16 character = 1 grapheme.
            const utf16Len = input.length;
            // fail early if UTF-16 length is too small
            if (utf16Len < minGraphemes) {
                return issue;
            }
            // if there is no minimum bounds, we can safely skip when UTF-16 is
            // within the maximum bounds.
            if (minGraphemes === 0 && utf16Len <= maxGraphemes) {
                return undefined;
            }
            const graphemeLen = getGraphemeLength(input);
            if (graphemeLen < minGraphemes) {
                return issue;
            }
            if (graphemeLen > maxGraphemes) {
                return issue;
            }
            return undefined;
        },
    };
};
const ISSUE_EXPECTED_BLOB = {
    ok: false,
    code: 'invalid_type',
    expected: 'blob',
    msg() {
        return `expected blob`;
    },
};
const BLOB_SCHEMA = {
    kind: 'schema',
    type: 'blob',
    '~run'(input, _flags) {
        if (typeof input !== 'object' || input === null) {
            return ISSUE_EXPECTED_BLOB;
        }
        if (interfaces.isBlob(input)) {
            return undefined;
        }
        if (interfaces.isLegacyBlob(input)) {
            const blob = {
                $type: 'blob',
                mimeType: input.mimeType,
                ref: { $link: input.cid },
                size: -1,
            };
            return ok(blob);
        }
        return ISSUE_EXPECTED_BLOB;
    },
    get '~standard'() {
        return lazyProperty(this, '~standard', toStandardSchema(this));
    },
};
// #__NO_SIDE_EFFECTS__
export const blob = () => {
    return BLOB_SCHEMA;
};
const ISSUE_EXPECTED_BYTES = {
    ok: false,
    code: 'invalid_type',
    expected: 'bytes',
    msg() {
        return `expected bytes`;
    },
};
const BYTES_SCHEMA = {
    kind: 'schema',
    type: 'bytes',
    '~run'(input, _flags) {
        if (!interfaces.isBytes(input)) {
            return ISSUE_EXPECTED_BYTES;
        }
        return undefined;
    },
    get '~standard'() {
        return lazyProperty(this, '~standard', toStandardSchema(this));
    },
};
// #__NO_SIDE_EFFECTS__
export const bytes = () => {
    return BYTES_SCHEMA;
};
// #__NO_SIDE_EFFECTS__
export const bytesSize = (minSize, maxSize = Infinity) => {
    const issue = {
        ok: false,
        code: 'invalid_bytes_size',
        minSize: minSize,
        maxSize: maxSize,
        msg() {
            return formatRangeMessage('a byte array', 'byte', minSize, maxSize);
        },
    };
    return {
        kind: 'constraint',
        type: 'bytes_size',
        minSize: minSize,
        maxSize: maxSize,
        '~run'(input, _flags) {
            let size;
            if (_isBytesWrapper(input)) {
                size = input.buf.length;
            }
            else {
                const str = input.$bytes;
                let bytes = str.length;
                if (str.charCodeAt(bytes - 1) === 0x3d) {
                    bytes--;
                }
                if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3d) {
                    bytes--;
                }
                size = (bytes * 3) >>> 2;
            }
            if (size < minSize) {
                return issue;
            }
            if (size > maxSize) {
                return issue;
            }
            return undefined;
        },
    };
};
const ISSUE_EXPECTED_CID_LINK = {
    ok: false,
    code: 'invalid_type',
    expected: 'cid-link',
    msg() {
        return `expected cid-link`;
    },
};
const CID_LINK_SCHEMA = {
    kind: 'schema',
    type: 'cid_link',
    '~run'(input, _flags) {
        if (!interfaces.isCidLink(input)) {
            return ISSUE_EXPECTED_CID_LINK;
        }
        return undefined;
    },
    get '~standard'() {
        return lazyProperty(this, '~standard', toStandardSchema(this));
    },
};
// #__NO_SIDE_EFFECTS__
export const cidLink = () => {
    return CID_LINK_SCHEMA;
};
// #__NO_SIDE_EFFECTS__
export const nullable = (wrapped) => {
    return {
        kind: 'schema',
        type: 'nullable',
        wrapped: wrapped,
        '~run'(input, flags) {
            if (input === null) {
                return undefined;
            }
            return wrapped['~run'](input, flags);
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const optional = (wrapped, defaultValue) => {
    return {
        kind: 'schema',
        type: 'optional',
        wrapped: wrapped,
        default: defaultValue,
        '~run'(input, flags) {
            if (input === undefined) {
                if (defaultValue === undefined) {
                    return undefined;
                }
                const value = typeof defaultValue === 'function' ? defaultValue() : defaultValue;
                return ok(value);
            }
            return wrapped['~run'](input, flags);
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
};
const isOptionalSchema = (schema) => {
    return schema.type === 'optional';
};
const ISSUE_TYPE_ARRAY = {
    ok: false,
    code: 'invalid_type',
    expected: 'array',
    msg() {
        return `expected array`;
    },
};
// #__NO_SIDE_EFFECTS__
export const array = (item) => {
    const resolvedShape = lazy(() => {
        return typeof item === 'function' ? item() : item;
    });
    return {
        kind: 'schema',
        type: 'array',
        get item() {
            return lazyProperty(this, 'item', resolvedShape.value);
        },
        get '~run'() {
            const shape = resolvedShape.value;
            const matcher = (input, flags) => {
                if (!isArray(input)) {
                    return ISSUE_TYPE_ARRAY;
                }
                let issues;
                let output;
                for (let idx = 0, len = input.length; idx < len; idx++) {
                    const val = input[idx];
                    const r = shape['~run'](val, flags);
                    if (r !== undefined) {
                        if (r.ok) {
                            if (output === undefined) {
                                output = input.slice();
                            }
                            output[idx] = r.value;
                        }
                        else {
                            issues = joinIssues(issues, prependPath(idx, r));
                            if (flags & FLAG_ABORT_EARLY) {
                                return issues;
                            }
                        }
                    }
                }
                if (issues !== undefined) {
                    return issues;
                }
                if (output !== undefined) {
                    return ok(output);
                }
                return undefined;
            };
            return lazyProperty(this, '~run', matcher);
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const arrayLength = (minLength, maxLength = Infinity) => {
    const issue = {
        ok: false,
        code: 'invalid_array_length',
        minLength: minLength,
        maxLength: maxLength,
        msg() {
            return formatRangeMessage('an array', 'item', minLength, maxLength);
        },
    };
    return {
        kind: 'constraint',
        type: 'array_length',
        minLength: minLength,
        maxLength: maxLength,
        '~run'(input, _flags) {
            const length = input.length;
            if (length < minLength) {
                return issue;
            }
            if (length > maxLength) {
                return issue;
            }
            return undefined;
        },
    };
};
const ISSUE_TYPE_OBJECT = {
    ok: false,
    code: 'invalid_type',
    expected: 'object',
    msg() {
        return `expected object`;
    },
};
const ISSUE_MISSING = {
    ok: false,
    code: 'missing_value',
    msg() {
        return `missing value`;
    },
};
const set = (obj, key, value) => {
    if (key === '__proto__') {
        Object.defineProperty(obj, key, { value });
    }
    else {
        obj[key] = value;
    }
};
// #__NO_SIDE_EFFECTS__
export const object = (shape) => {
    const resolvedEntries = lazy(() => {
        const resolved = [];
        for (const key in shape) {
            const schema = shape[key];
            resolved.push({
                key: key,
                schema: schema,
                optional: isOptionalSchema(schema),
                missing: prependPath(key, ISSUE_MISSING),
            });
        }
        return resolved;
    });
    return {
        kind: 'schema',
        type: 'object',
        get shape() {
            // if we just return the shape as is then it wouldn't be the same exact
            // shape when getters are present.
            const resolved = resolvedEntries.value;
            const obj = {};
            for (const entry of resolved) {
                obj[entry.key] = entry.schema;
            }
            return lazyProperty(this, 'shape', obj);
        },
        get '~run'() {
            const shape = resolvedEntries.value;
            const len = shape.length;
            const generateFastpass = () => {
                const fields = [
                    ['$ok', ok],
                    ['$joinIssues', joinIssues],
                    ['$prependPath', prependPath],
                ];
                let doc = `let $iss,$out;`;
                for (let idx = 0; idx < len; idx++) {
                    const entry = shape[idx];
                    const key = entry.key;
                    const esckey = JSON.stringify(key);
                    const id = `_${idx}`;
                    doc += `{const $val=$in[${esckey}];`;
                    if (entry.optional) {
                        doc += `if($val!==undefined){`;
                    }
                    else {
                        doc += `if($val!==undefined||${esckey} in $in){`;
                    }
                    doc += `const $res=${id}$schema["~run"]($val,$flags);if($res!==undefined)if($res.ok)${key !== '__proto__' ? `($out??={...$in})[${esckey}]=$res.value` : `Object.defineProperty($out??={...$in},${esckey},{value:$res.value})`};else if((($iss=$joinIssues($iss,$prependPath(${esckey},$res))),$flags&${FLAG_ABORT_EARLY}))return $iss;}`;
                    if (entry.optional) {
                        const schema = entry.schema;
                        const innerSchema = schema.wrapped;
                        const defaultValue = schema.default;
                        fields.push([`${id}$schema`, innerSchema]);
                        if (defaultValue !== undefined) {
                            const calls = typeof defaultValue === 'function' ? `${id}$default()` : `${id}$default`;
                            fields.push([`${id}$default`, defaultValue]);
                            doc +=
                                key !== '__proto__'
                                    ? `else($out??={...$in})[${esckey}]=${calls};`
                                    : `else Object.defineProperty($out??={...$in},${esckey},{value:${calls}});`;
                        }
                    }
                    else {
                        fields.push([`${id}$schema`, entry.schema]);
                        fields.push([`${id}$missing`, entry.missing]);
                        doc += `else if((($iss=$joinIssues($iss,${id}$missing)),$flags&${FLAG_ABORT_EARLY}))return $iss;`;
                    }
                    doc += `}`;
                }
                doc += `if($iss!==undefined)return $iss;if($out!==undefined)return $ok($out);`;
                const fn = new Function(`[${fields.map(([id]) => id).join(',')}]`, `return function matcher($in,$flags){${doc}}`);
                return fn(fields.map(([, field]) => field));
            };
            if (allowsEval.value) {
                const fastpass = generateFastpass();
                const matcher = (input, flags) => {
                    if (!isObject(input)) {
                        return ISSUE_TYPE_OBJECT;
                    }
                    return fastpass(input, flags);
                };
                return lazyProperty(this, '~run', matcher);
            }
            const matcher = (input, flags) => {
                if (!isObject(input)) {
                    return ISSUE_TYPE_OBJECT;
                }
                let issues;
                let output;
                for (let idx = 0; idx < len; idx++) {
                    const entry = shape[idx];
                    const key = entry.key;
                    const value = input[key];
                    if (!entry.optional && value === undefined && !(key in input)) {
                        issues = joinIssues(issues, entry.missing);
                        if (flags & FLAG_ABORT_EARLY) {
                            return issues;
                        }
                        continue;
                    }
                    const r = entry.schema['~run'](value, flags);
                    if (r !== undefined) {
                        if (r.ok) {
                            if (output === undefined) {
                                output = { ...input };
                            }
                            /*#__INLINE__*/ set(output, key, r.value);
                        }
                        else {
                            issues = joinIssues(issues, prependPath(key, r));
                            if (flags & FLAG_ABORT_EARLY) {
                                return issues;
                            }
                        }
                    }
                }
                if (issues !== undefined) {
                    return issues;
                }
                if (output !== undefined) {
                    return ok(output);
                }
                return undefined;
            };
            return lazyProperty(this, '~run', matcher);
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const record = (key, object) => {
    const validatedObject = lazy(() => {
        const shape = object.shape;
        let t = shape.$type;
        assert(t !== undefined, `expected $type in record to be defined`);
        if (t.type === 'optional') {
            t = t.wrapped;
        }
        assert(t.type === 'literal' && typeof t.expected === 'string', `expected $type to be a string literal`);
        return object;
    });
    return {
        kind: 'schema',
        type: 'record',
        key: key,
        get object() {
            return lazyProperty(this, 'object', validatedObject.value);
        },
        '~run'(input, flags) {
            return lazyProperty(this, '~run', validatedObject.value['~run'])(input, flags);
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
};
const ISSUE_VARIANT_MISSING = /*#__PURE__*/ prependPath('$type', ISSUE_MISSING);
const ISSUE_VARIANT_TYPE = /*#__PURE__*/ prependPath('$type', ISSUE_TYPE_STRING);
// #__NO_SIDE_EFFECTS__
export const variant = (members, closed = false) => {
    return {
        kind: 'schema',
        type: 'variant',
        members: members,
        closed: closed,
        get '~run'() {
            const map = Object.fromEntries(members.map((member, idx) => {
                const shape = member.shape;
                let t = shape.$type;
                assert(t !== undefined, `expected $type in variant member #${idx} to be defined`);
                if (t.type === 'optional') {
                    t = t.wrapped;
                }
                assert(t.type === 'literal' && typeof t.expected === 'string', `expected $type in variant member #${idx} to be a string literal`);
                return [t.expected, member];
            }));
            const issue = {
                ok: false,
                code: 'invalid_variant',
                expected: Object.keys(map),
                msg() {
                    return `expected ${separatedList(Object.keys(map), 'or')}`;
                },
            };
            const matcher = (input, flags) => {
                if (!isObject(input)) {
                    return ISSUE_TYPE_OBJECT;
                }
                const type = input.$type;
                if (type === undefined && !('$type' in input)) {
                    return ISSUE_VARIANT_MISSING;
                }
                if (typeof type !== 'string') {
                    return closed ? issue : ISSUE_VARIANT_TYPE;
                }
                const schema = map[type];
                if (schema === undefined) {
                    if (closed) {
                        return issue;
                    }
                    return undefined;
                }
                return schema['~run'](input, flags);
            };
            return lazyProperty(this, '~run', matcher);
        },
        get '~standard'() {
            return lazyProperty(this, '~standard', toStandardSchema(this));
        },
    };
};
const ISSUE_TYPE_UNKNOWN = {
    ok: false,
    code: 'invalid_type',
    expected: 'unknown',
    msg() {
        return `expected unknown`;
    },
};
const UNKNOWN_SCHEMA = {
    kind: 'schema',
    type: 'unknown',
    '~run'(input, _flags) {
        if (typeof input !== 'object' || input === null) {
            return ISSUE_TYPE_UNKNOWN;
        }
        return undefined;
    },
    get '~standard'() {
        return lazyProperty(this, '~standard', toStandardSchema(this));
    },
};
// #__NO_SIDE_EFFECTS__
export const unknown = () => {
    return UNKNOWN_SCHEMA;
};
// #__NO_SIDE_EFFECTS__
export const procedure = (nsid, options) => {
    // `schema` can be a getter, and we'd have to resolve that getter.
    return {
        kind: 'metadata',
        type: 'xrpc_procedure',
        nsid: nsid,
        params: options.params,
        get input() {
            let val = options.input;
            switch (val?.type) {
                case 'lex': {
                    val = {
                        type: 'lex',
                        schema: val.schema,
                    };
                    break;
                }
            }
            return lazyProperty(this, 'input', val);
        },
        get output() {
            let val = options.output;
            switch (val?.type) {
                case 'lex': {
                    val = {
                        type: 'lex',
                        schema: val.schema,
                    };
                    break;
                }
            }
            return lazyProperty(this, 'output', val);
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const query = (nsid, options) => {
    // `schema` can be a getter, and we'd have to resolve that getter.
    return {
        kind: 'metadata',
        type: 'xrpc_query',
        nsid: nsid,
        params: options.params,
        get output() {
            let val = options.output;
            switch (val?.type) {
                case 'lex': {
                    val = {
                        type: 'lex',
                        schema: val.schema,
                    };
                }
            }
            return lazyProperty(this, 'output', val);
        },
    };
};
// #__NO_SIDE_EFFECTS__
export const subscription = (nsid, options) => {
    // `message` can be a getter, and we'd have to resolve that getter.
    return {
        kind: 'metadata',
        type: 'xrpc_subscription',
        nsid: nsid,
        params: options.params,
        get message() {
            return lazyProperty(this, 'message', options.message);
        },
    };
};
//# sourceMappingURL=index.js.map