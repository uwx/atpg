import type { StandardSchemaV1 } from '@standard-schema/spec';
import * as syntax from '../syntax/index.js';
import * as interfaces from '../interfaces/index.js';
import type { $type } from '../types/brand.js';
type Identity<T> = T;
type Flatten<T> = Identity<{
    [K in keyof T]: T[K];
}>;
type InputType = 'unknown' | 'null' | 'undefined' | 'string' | 'integer' | 'boolean' | 'blob' | 'bytes' | 'cid-link' | 'object' | 'array';
type StringFormatMap = {
    'at-identifier': syntax.ActorIdentifier;
    'at-uri': syntax.ResourceUri;
    cid: syntax.Cid;
    datetime: syntax.Datetime;
    did: syntax.Did;
    handle: syntax.Handle;
    language: syntax.LanguageCode;
    nsid: syntax.Nsid;
    'record-key': syntax.RecordKey;
    tid: syntax.Tid;
    uri: syntax.GenericUri;
};
export type StringFormat = keyof StringFormatMap;
type Literal = string | number | boolean;
type Key = string | number;
type IssueFormatter = () => string;
export type IssueLeaf = {
    ok: false;
    msg: IssueFormatter;
} & ({
    code: 'missing_value';
} | {
    code: 'invalid_literal';
    expected: readonly Literal[];
} | {
    code: 'invalid_type';
    expected: InputType;
} | {
    code: 'invalid_variant';
    expected: string[];
} | {
    code: 'invalid_integer_range';
    min: number;
    max: number;
} | {
    code: 'invalid_string_format';
    expected: StringFormat;
} | {
    code: 'invalid_string_graphemes';
    minGraphemes: number;
    maxGraphemes: number;
} | {
    code: 'invalid_string_length';
    minLength: number;
    maxLength: number;
} | {
    code: 'invalid_array_length';
    minLength: number;
    maxLength: number;
} | {
    code: 'invalid_bytes_size';
    minSize: number;
    maxSize: number;
});
export type IssueTree = IssueLeaf | {
    ok: false;
    code: 'prepend';
    key: Key;
    tree: IssueTree;
} | {
    ok: false;
    code: 'join';
    left: IssueTree;
    right: IssueTree;
};
export type Issue = {
    code: 'missing_value';
    path: Key[];
} | {
    code: 'invalid_literal';
    path: Key[];
    expected: readonly Literal[];
} | {
    code: 'invalid_type';
    path: Key[];
    expected: InputType;
} | {
    code: 'invalid_variant';
    path: Key[];
    expected: string[];
} | {
    code: 'invalid_integer_range';
    path: Key[];
    min: number;
    max: number;
} | {
    code: 'invalid_string_format';
    path: Key[];
    expected: StringFormat;
} | {
    code: 'invalid_string_graphemes';
    path: Key[];
    minGraphemes: number;
    maxGraphemes: number;
} | {
    code: 'invalid_string_length';
    path: Key[];
    minLength: number;
    maxLength: number;
} | {
    code: 'invalid_array_length';
    path: Key[];
    minLength: number;
    maxLength: number;
} | {
    code: 'invalid_bytes_size';
    path: Key[];
    minSize: number;
    maxSize: number;
};
export type Ok<T> = {
    ok: true;
    value: T;
};
export type Err = {
    ok: false;
    readonly message: string;
    readonly issues: readonly Issue[];
    throw(): never;
};
export type ValidationResult<T> = Ok<T> | Err;
export declare const ok: <T>(value: T) => Ok<T>;
declare const kType: unique symbol;
type kType = typeof kType;
export declare const FLAG_EMPTY = 0;
export declare const FLAG_ABORT_EARLY: number;
type MatcherResult = undefined | Ok<unknown> | IssueTree;
type Matcher = (input: unknown, flags: number) => MatcherResult;
type LexStandardSchemaResult<T extends BaseSchema> = StandardSchemaV1.Result<InferOutput<T>>;
interface LexStandardSchema<T extends BaseSchema> extends StandardSchemaV1.Props<unknown> {
    readonly validate: (value: unknown) => LexStandardSchemaResult<T> | Promise<LexStandardSchemaResult<T>>;
    readonly types?: StandardSchemaV1.Types<InferInput<T>, InferOutput<T>>;
}
export interface BaseSchema<TInput = unknown, TOutput = TInput> {
    readonly kind: 'schema';
    readonly type: string;
    readonly '~run': Matcher;
    readonly '~standard': LexStandardSchema<this>;
    readonly [kType]?: {
        in: TInput;
        out: TOutput;
    };
}
export type InferInput<T extends BaseSchema> = NonNullable<T[kType]>['in'];
export type InferOutput<T extends BaseSchema> = NonNullable<T[kType]>['out'];
export declare class ValidationError extends Error {
    #private;
    readonly name = "ValidationError";
    constructor(issueTree: IssueTree);
    get message(): string;
    get issues(): readonly Issue[];
}
export declare const is: <const TSchema extends BaseSchema>(schema: TSchema, input: unknown) => input is InferInput<TSchema>;
export declare const safeParse: <const TSchema extends BaseSchema>(schema: TSchema, input: unknown) => ValidationResult<InferOutput<TSchema>>;
export declare const parse: <const TSchema extends BaseSchema>(schema: TSchema, input: unknown) => InferOutput<TSchema>;
export interface BaseConstraint<TType = unknown> {
    readonly kind: 'constraint';
    readonly type: string;
    readonly '~run': (input: TType, flags: number) => MatcherResult;
}
type ConstraintTuple<T> = readonly [BaseConstraint<T>, ...BaseConstraint<T>[]];
export type SchemaWithConstraint<TItem extends BaseSchema, TConstraints extends ConstraintTuple<InferOutput<TItem>>> = TItem & {
    readonly constraints: TConstraints;
};
export declare const constrain: <TItem extends BaseSchema, const TConstraints extends ConstraintTuple<InferOutput<TItem>>>(base: TItem, constraints: TConstraints) => SchemaWithConstraint<TItem, TConstraints>;
export interface BaseMetadata {
    readonly kind: 'metadata';
    readonly type: string;
}
export interface LiteralSchema<T extends Literal = Literal> extends BaseSchema<T> {
    readonly type: 'literal';
    readonly expected: T;
}
export declare const literal: <T extends Literal>(value: T) => LiteralSchema<T>;
export interface LiteralEnumSchema<TEnums extends readonly Literal[] = []> extends BaseSchema<TEnums[number]> {
    readonly type: 'literal_enum';
    readonly expected: TEnums;
}
export declare const literalEnum: <const TEnums extends readonly Literal[]>(values: TEnums) => LiteralEnumSchema<TEnums>;
export interface BooleanSchema extends BaseSchema<boolean> {
    readonly type: 'boolean';
}
export declare const boolean: () => BooleanSchema;
export interface IntegerSchema extends BaseSchema<number> {
    readonly type: 'integer';
}
export declare const integer: () => IntegerSchema;
export interface IntegerRangeConstraint<TMin extends number = number, TMax extends number = number> extends BaseConstraint<number> {
    readonly type: 'integer_range';
    readonly min: TMin;
    readonly max: TMax;
}
export declare const integerRange: {
    <const TMin extends number>(min: TMin): IntegerRangeConstraint<TMin>;
    <const TMin extends number, const TMax extends number>(min: TMin, max: TMax): IntegerRangeConstraint<TMin, TMax>;
};
export interface StringSchema<T extends string = string> extends BaseSchema<T> {
    readonly type: 'string';
    readonly format: null;
}
export interface FormattedStringSchema<TFormat extends keyof StringFormatMap = keyof StringFormatMap> extends BaseSchema<StringFormatMap[TFormat]> {
    readonly type: 'string';
    readonly format: TFormat;
}
export declare const string: <T extends string = string>() => StringSchema<T>;
export declare const actorIdentifierString: () => FormattedStringSchema<"at-identifier">;
export declare const resourceUriString: () => FormattedStringSchema<"at-uri">;
export declare const cidString: () => FormattedStringSchema<"cid">;
export declare const datetimeString: () => FormattedStringSchema<"datetime">;
export declare const didString: () => FormattedStringSchema<"did">;
export declare const handleString: () => FormattedStringSchema<"handle">;
export declare const languageCodeString: () => FormattedStringSchema<"language">;
export declare const nsidString: () => FormattedStringSchema<"nsid">;
export declare const recordKeyString: () => FormattedStringSchema<"record-key">;
export declare const tidString: () => FormattedStringSchema<"tid">;
export declare const genericUriString: () => FormattedStringSchema<"uri">;
export interface StringLengthConstraint<TMinLength extends number = number, TMaxLength extends number = number> extends BaseConstraint<string> {
    readonly type: 'string_length';
    readonly minLength: TMinLength;
    readonly maxLength: TMaxLength;
}
export declare const stringLength: {
    <const TMinLength extends number>(min: TMinLength): StringLengthConstraint<TMinLength>;
    <const TMinLength extends number, const TMaxLength extends number>(min: TMinLength, max: TMaxLength): StringLengthConstraint<TMinLength, TMaxLength>;
};
export interface StringGraphemesConstraint<TMinGraphemes extends number = number, TMaxGraphemes extends number = number> extends BaseConstraint<string> {
    readonly type: 'string_graphemes';
    readonly minGraphemes: TMinGraphemes;
    readonly maxGraphemes: TMaxGraphemes;
}
export declare const stringGraphemes: {
    <const TMinGraphemes extends number>(min: TMinGraphemes): StringGraphemesConstraint<TMinGraphemes>;
    <const TMinGraphemes extends number, const TMaxGraphemes extends number>(min: TMinGraphemes, max: TMaxGraphemes): StringGraphemesConstraint<TMinGraphemes, TMaxGraphemes>;
};
export interface BlobSchema extends BaseSchema<interfaces.Blob | interfaces.LegacyBlob, interfaces.Blob> {
    readonly type: 'blob';
}
export declare const blob: () => BlobSchema;
export interface BytesSchema extends BaseSchema<interfaces.Bytes, interfaces.Bytes> {
    readonly type: 'bytes';
}
export declare const bytes: () => BytesSchema;
export interface BytesSizeConstraint<TMinLength extends number = number, TMaxLength extends number = number> extends BaseConstraint<interfaces.Bytes> {
    readonly type: 'bytes_size';
    readonly minSize: TMinLength;
    readonly maxSize: TMaxLength;
}
export declare const bytesSize: {
    <const TMinLength extends number>(min: TMinLength): BytesSizeConstraint<TMinLength>;
    <const TMinLength extends number, const TMaxLength extends number>(min: TMinLength, max: TMaxLength): BytesSizeConstraint<TMinLength, TMaxLength>;
};
export interface CidLinkSchema extends BaseSchema<interfaces.CidLink, interfaces.CidLink> {
    readonly type: 'cid_link';
}
export declare const cidLink: () => CidLinkSchema;
export interface NullableSchema<TItem extends BaseSchema> extends BaseSchema<InferInput<TItem> | null, InferOutput<TItem> | null> {
    readonly type: 'nullable';
    readonly wrapped: TItem;
}
export declare const nullable: <TItem extends BaseSchema>(wrapped: TItem) => NullableSchema<TItem>;
export type DefaultValue<TItem extends BaseSchema> = InferOutput<TItem> | (() => InferOutput<TItem>) | undefined;
export type InferOptionalOutput<TItem extends BaseSchema, TDefault extends DefaultValue<TItem>> = undefined extends TDefault ? InferOutput<TItem> | undefined : InferOutput<TItem>;
export interface OptionalSchema<TItem extends BaseSchema = BaseSchema, TDefault extends DefaultValue<TItem> = DefaultValue<TItem>> extends BaseSchema<InferInput<TItem> | undefined, InferOptionalOutput<TItem, TDefault>> {
    readonly type: 'optional';
    readonly wrapped: TItem;
    readonly default: TDefault;
}
export declare const optional: {
    <TItem extends BaseSchema>(wrapped: TItem): OptionalSchema<TItem, undefined>;
    <TItem extends BaseSchema, TDefault extends DefaultValue<TItem>>(wrapped: TItem, defaultValue: TDefault): OptionalSchema<TItem, TDefault>;
};
export interface ArraySchema<TItem extends BaseSchema = BaseSchema> extends BaseSchema<unknown[], unknown[]> {
    readonly type: 'array';
    readonly item: TItem;
    readonly [kType]?: {
        in: InferInput<TItem>[];
        out: InferOutput<TItem>[];
    };
}
export declare const array: <TItem extends BaseSchema>(item: TItem | (() => TItem)) => ArraySchema<TItem>;
export interface ArrayLengthConstraint<TMinLength extends number = number, TMaxLength extends number = number> extends BaseConstraint<unknown[]> {
    readonly type: 'array_length';
    readonly minLength: TMinLength;
    readonly maxLength: TMaxLength;
}
export declare const arrayLength: {
    <const TMinLength extends number>(min: TMinLength): ArrayLengthConstraint<TMinLength>;
    <const TMinLength extends number, const TMaxLength extends number>(min: TMinLength, max: TMaxLength): ArrayLengthConstraint<TMinLength, TMaxLength>;
};
export type LooseObjectShape = Record<string, any>;
export type ObjectShape = Record<string, BaseSchema>;
export type OptionalObjectInputKeys<TShape extends ObjectShape> = {
    [Key in keyof TShape]: TShape[Key] extends OptionalSchema<any, any> ? Key : never;
}[keyof TShape];
export type OptionalObjectOutputKeys<TShape extends ObjectShape> = {
    [Key in keyof TShape]: TShape[Key] extends OptionalSchema<any, infer Default> ? undefined extends Default ? Key : never : never;
}[keyof TShape];
type InferObjectInput<TShape extends ObjectShape> = Flatten<{
    -readonly [Key in keyof TShape as Key extends OptionalObjectInputKeys<TShape> ? never : Key]: InferInput<TShape[Key]>;
} & {
    -readonly [Key in keyof TShape as Key extends OptionalObjectInputKeys<TShape> ? Key : never]?: InferInput<TShape[Key]>;
}>;
type InferObjectOutput<TShape extends ObjectShape> = Flatten<{
    -readonly [Key in keyof TShape as Key extends OptionalObjectOutputKeys<TShape> ? never : Key]: InferOutput<TShape[Key]>;
} & {
    -readonly [Key in keyof TShape as Key extends OptionalObjectOutputKeys<TShape> ? Key : never]?: InferOutput<TShape[Key]>;
}>;
export interface ObjectSchema<TShape extends LooseObjectShape = LooseObjectShape> extends BaseSchema<Record<string, unknown>> {
    readonly type: 'object';
    readonly shape: Readonly<TShape>;
    readonly [kType]?: {
        in: InferObjectInput<TShape>;
        out: InferObjectOutput<TShape>;
    };
}
export declare const object: <TShape extends LooseObjectShape>(shape: TShape) => ObjectSchema<TShape>;
export type RecordObjectShape = {
    $type: LiteralSchema<syntax.Nsid>;
    [key: string]: BaseSchema;
};
export type RecordKeySchema = StringSchema | FormattedStringSchema | LiteralSchema<string>;
export type RecordObjectSchema = ObjectSchema<RecordObjectShape>;
export interface RecordSchema<TObject extends ObjectSchema, TKey extends RecordKeySchema> extends BaseSchema<Record<string, unknown>> {
    readonly type: 'record';
    readonly key: TKey;
    readonly object: TObject;
    readonly [kType]?: {
        in: InferInput<TObject>;
        out: InferOutput<TObject>;
    };
}
export declare const record: <TKey extends RecordKeySchema, TObject extends ObjectSchema>(key: TKey, object: TObject) => RecordSchema<TObject, TKey>;
type VariantTuple = readonly ObjectSchema<any>[];
type InferVariantInput<TMembers extends VariantTuple> = $type.enforce<InferInput<TMembers[number]>>;
type InferVariantOutput<TMembers extends VariantTuple> = $type.enforce<InferOutput<TMembers[number]>>;
export interface VariantSchema<TMembers extends VariantTuple = VariantTuple, TClosed extends boolean = boolean> extends BaseSchema<Record<string, unknown>> {
    readonly type: 'variant';
    readonly members: TMembers;
    readonly closed: TClosed;
    readonly [kType]?: {
        in: InferVariantInput<TMembers>;
        out: InferVariantOutput<TMembers>;
    };
}
export declare const variant: {
    <const TMembers extends VariantTuple>(members: TMembers): VariantSchema<TMembers>;
    <const TMembers extends VariantTuple, TClosed extends boolean>(members: TMembers, closed: TClosed): VariantSchema<TMembers, TClosed>;
};
export interface UnknownSchema extends BaseSchema<Record<string, unknown>> {
    readonly type: 'unknown';
}
export declare const unknown: () => UnknownSchema;
export interface XRPCLexBodyParam<TSchema extends ObjectSchema | VariantSchema = ObjectSchema | VariantSchema> {
    readonly type: 'lex';
    readonly schema: TSchema;
}
export interface XRPCBlobBodyParam {
    readonly type: 'blob';
    readonly encoding?: string[];
}
export type XRPCBodyParam = XRPCLexBodyParam | XRPCBlobBodyParam | null;
export type InferXRPCBodyInput<T extends XRPCBodyParam> = T extends XRPCLexBodyParam<infer Schema> ? InferInput<Schema> : T extends XRPCBlobBodyParam ? Blob : T extends null ? void : never;
export type InferXRPCBodyOutput<T extends XRPCBodyParam> = T extends XRPCLexBodyParam<infer Schema> ? InferOutput<Schema> : T extends XRPCBlobBodyParam ? Blob : T extends null ? void : never;
export interface XRPCProcedureMetadata<TParams extends ObjectSchema | null = ObjectSchema | null, TInput extends XRPCBodyParam = XRPCBodyParam, TOutput extends XRPCBodyParam = XRPCBodyParam, TNsid extends syntax.Nsid = syntax.Nsid> extends BaseMetadata {
    readonly type: 'xrpc_procedure';
    readonly nsid: TNsid;
    readonly params: TParams;
    readonly input: TInput;
    readonly output: TOutput;
}
export declare const procedure: <TNsid extends syntax.Nsid, TParams extends ObjectSchema | null, TInput extends XRPCBodyParam, TOutput extends XRPCBodyParam>(nsid: TNsid, options: {
    params: TParams;
    input: TInput;
    output: TOutput;
}) => XRPCProcedureMetadata<TParams, TInput, TOutput, TNsid>;
export interface XRPCQueryMetadata<TParams extends ObjectSchema | null = ObjectSchema | null, TOutput extends XRPCBodyParam = XRPCBodyParam, TNsid extends syntax.Nsid = syntax.Nsid> extends BaseMetadata {
    readonly type: 'xrpc_query';
    readonly nsid: TNsid;
    readonly params: TParams;
    readonly output: TOutput;
}
export declare const query: <TNsid extends syntax.Nsid, TParams extends ObjectSchema | null, TOutput extends XRPCBodyParam>(nsid: TNsid, options: {
    params: TParams;
    output: TOutput;
}) => XRPCQueryMetadata<TParams, TOutput, TNsid>;
export interface XRPCSubscriptionMetadata<TParams extends ObjectSchema | null = ObjectSchema | null, TMessage extends ObjectSchema<any> | VariantSchema<any, any> | null = ObjectSchema<any> | VariantSchema<any, any> | null, TNsid extends syntax.Nsid = syntax.Nsid> extends BaseMetadata {
    readonly type: 'xrpc_subscription';
    readonly nsid: TNsid;
    readonly params: TParams;
    readonly message: TMessage;
}
export declare const subscription: <TNsid extends syntax.Nsid, TParams extends ObjectSchema | null, TMessage extends ObjectSchema<any> | VariantSchema<any, any> | null>(nsid: TNsid, options: {
    params: TParams;
    readonly message: TMessage;
}) => XRPCSubscriptionMetadata<TParams, TMessage, TNsid>;
export {};
//# sourceMappingURL=index.d.ts.map