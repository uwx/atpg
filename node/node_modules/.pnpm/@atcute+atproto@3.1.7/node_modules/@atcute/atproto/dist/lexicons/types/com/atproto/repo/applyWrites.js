import * as v from '@atcute/lexicons/validations';
import * as ComAtprotoRepoDefs from './defs.js';
const _createSchema = /*#__PURE__*/ v.object({
    $type: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.literal('com.atproto.repo.applyWrites#create')),
    collection: /*#__PURE__*/ v.nsidString(),
    /**
     * NOTE: maxLength is redundant with record-key format. Keeping it temporarily to ensure backwards compatibility.
     * @maxLength 512
     */
    rkey: /*#__PURE__*/ v.optional(
    /*#__PURE__*/ v.constrain(/*#__PURE__*/ v.recordKeyString(), [/*#__PURE__*/ v.stringLength(0, 512)])),
    value: /*#__PURE__*/ v.unknown(),
});
const _createResultSchema = /*#__PURE__*/ v.object({
    $type: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.literal('com.atproto.repo.applyWrites#createResult')),
    cid: /*#__PURE__*/ v.cidString(),
    uri: /*#__PURE__*/ v.resourceUriString(),
    validationStatus: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.string()),
});
const _deleteSchema = /*#__PURE__*/ v.object({
    $type: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.literal('com.atproto.repo.applyWrites#delete')),
    collection: /*#__PURE__*/ v.nsidString(),
    rkey: /*#__PURE__*/ v.recordKeyString(),
});
const _deleteResultSchema = /*#__PURE__*/ v.object({
    $type: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.literal('com.atproto.repo.applyWrites#deleteResult')),
});
const _mainSchema = /*#__PURE__*/ v.procedure('com.atproto.repo.applyWrites', {
    params: null,
    input: {
        type: 'lex',
        schema: /*#__PURE__*/ v.object({
            /**
             * The handle or DID of the repo (aka, current account).
             */
            repo: /*#__PURE__*/ v.actorIdentifierString(),
            /**
             * If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.
             */
            swapCommit: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.cidString()),
            /**
             * Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons.
             */
            validate: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.boolean()),
            get writes() {
                return /*#__PURE__*/ v.array(
                /*#__PURE__*/ v.variant([createSchema, deleteSchema, updateSchema], true));
            },
        }),
    },
    output: {
        type: 'lex',
        schema: /*#__PURE__*/ v.object({
            get commit() {
                return /*#__PURE__*/ v.optional(ComAtprotoRepoDefs.commitMetaSchema);
            },
            get results() {
                return /*#__PURE__*/ v.optional(
                /*#__PURE__*/ v.array(
                /*#__PURE__*/ v.variant([createResultSchema, deleteResultSchema, updateResultSchema], true)));
            },
        }),
    },
});
const _updateSchema = /*#__PURE__*/ v.object({
    $type: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.literal('com.atproto.repo.applyWrites#update')),
    collection: /*#__PURE__*/ v.nsidString(),
    rkey: /*#__PURE__*/ v.recordKeyString(),
    value: /*#__PURE__*/ v.unknown(),
});
const _updateResultSchema = /*#__PURE__*/ v.object({
    $type: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.literal('com.atproto.repo.applyWrites#updateResult')),
    cid: /*#__PURE__*/ v.cidString(),
    uri: /*#__PURE__*/ v.resourceUriString(),
    validationStatus: /*#__PURE__*/ v.optional(/*#__PURE__*/ v.string()),
});
export const createSchema = _createSchema;
export const createResultSchema = _createResultSchema;
export const deleteSchema = _deleteSchema;
export const deleteResultSchema = _deleteResultSchema;
export const mainSchema = _mainSchema;
export const updateSchema = _updateSchema;
export const updateResultSchema = _updateResultSchema;
//# sourceMappingURL=applyWrites.js.map