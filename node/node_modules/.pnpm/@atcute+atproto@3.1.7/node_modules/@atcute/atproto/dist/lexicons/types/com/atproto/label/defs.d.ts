import * as v from '@atcute/lexicons/validations';
declare const _labelSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.label.defs#label">, undefined>;
    /**
     * Optionally, CID specifying the specific version of 'uri' resource this label applies to.
     */
    cid: v.OptionalSchema<v.FormattedStringSchema<"cid">, undefined>;
    /**
     * Timestamp when this label was created.
     */
    cts: v.FormattedStringSchema<"datetime">;
    /**
     * Timestamp at which this label expires (no longer applies).
     */
    exp: v.OptionalSchema<v.FormattedStringSchema<"datetime">, undefined>;
    /**
     * If true, this is a negation label, overwriting a previous label.
     */
    neg: v.OptionalSchema<v.BooleanSchema, undefined>;
    /**
     * Signature of dag-cbor encoded label.
     */
    sig: v.OptionalSchema<v.BytesSchema, undefined>;
    /**
     * DID of the actor who created this label.
     */
    src: v.FormattedStringSchema<"did">;
    /**
     * AT URI of the record, repository (account), or other resource that this label applies to.
     */
    uri: v.FormattedStringSchema<"uri">;
    /**
     * The short string name of the value or type of this label.
     * @maxLength 128
     */
    val: v.SchemaWithConstraint<v.StringSchema<string>, readonly [v.StringLengthConstraint<0, 128>]>;
    /**
     * The AT Protocol version of the label object.
     */
    ver: v.OptionalSchema<v.IntegerSchema, undefined>;
}>;
declare const _labelValueSchema: v.StringSchema<(string & {}) | "!hide" | "!no-promote" | "!no-unauthenticated" | "!warn" | "dmca-violation" | "doxxing" | "gore" | "nsfl" | "nudity" | "porn" | "sexual">;
declare const _labelValueDefinitionSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.label.defs#labelValueDefinition">, undefined>;
    /**
     * Does the user need to have adult content enabled in order to configure this label?
     */
    adultOnly: v.OptionalSchema<v.BooleanSchema, undefined>;
    /**
     * What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.
     */
    blurs: v.StringSchema<(string & {}) | "content" | "media" | "none">;
    /**
     * The default setting for this label.
     * @default "warn"
     */
    defaultSetting: v.OptionalSchema<v.StringSchema<(string & {}) | "hide" | "ignore" | "warn">, "warn">;
    /**
     * The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).
     * @maxLength 100
     * @maxGraphemes 100
     */
    identifier: v.SchemaWithConstraint<v.StringSchema<string>, readonly [v.StringLengthConstraint<0, 100>, v.StringGraphemesConstraint<0, 100>]>;
    readonly locales: v.ArraySchema<labelValueDefinitionStringsSchema>;
    /**
     * How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.
     */
    severity: v.StringSchema<(string & {}) | "none" | "alert" | "inform">;
}>;
declare const _labelValueDefinitionStringsSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.label.defs#labelValueDefinitionStrings">, undefined>;
    /**
     * A longer description of what the label means and why it might be applied.
     * @maxLength 100000
     * @maxGraphemes 10000
     */
    description: v.SchemaWithConstraint<v.StringSchema<string>, readonly [v.StringLengthConstraint<0, 100000>, v.StringGraphemesConstraint<0, 10000>]>;
    /**
     * The code of the language these strings are written in.
     */
    lang: v.FormattedStringSchema<"language">;
    /**
     * A short human-readable name for the label.
     * @maxLength 640
     * @maxGraphemes 64
     */
    name: v.SchemaWithConstraint<v.StringSchema<string>, readonly [v.StringLengthConstraint<0, 640>, v.StringGraphemesConstraint<0, 64>]>;
}>;
declare const _selfLabelSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.label.defs#selfLabel">, undefined>;
    /**
     * The short string name of the value or type of this label.
     * @maxLength 128
     */
    val: v.SchemaWithConstraint<v.StringSchema<string>, readonly [v.StringLengthConstraint<0, 128>]>;
}>;
declare const _selfLabelsSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.label.defs#selfLabels">, undefined>;
    /**
     * @maxLength 10
     */
    readonly values: v.SchemaWithConstraint<v.ArraySchema<selfLabelSchema>, readonly [v.ArrayLengthConstraint<0, 10>]>;
}>;
type label$schematype = typeof _labelSchema;
type labelValue$schematype = typeof _labelValueSchema;
type labelValueDefinition$schematype = typeof _labelValueDefinitionSchema;
type labelValueDefinitionStrings$schematype = typeof _labelValueDefinitionStringsSchema;
type selfLabel$schematype = typeof _selfLabelSchema;
type selfLabels$schematype = typeof _selfLabelsSchema;
export interface labelSchema extends label$schematype {
}
export interface labelValueSchema extends labelValue$schematype {
}
export interface labelValueDefinitionSchema extends labelValueDefinition$schematype {
}
export interface labelValueDefinitionStringsSchema extends labelValueDefinitionStrings$schematype {
}
export interface selfLabelSchema extends selfLabel$schematype {
}
export interface selfLabelsSchema extends selfLabels$schematype {
}
export declare const labelSchema: labelSchema;
export declare const labelValueSchema: labelValueSchema;
export declare const labelValueDefinitionSchema: labelValueDefinitionSchema;
export declare const labelValueDefinitionStringsSchema: labelValueDefinitionStringsSchema;
export declare const selfLabelSchema: selfLabelSchema;
export declare const selfLabelsSchema: selfLabelsSchema;
export interface Label extends v.InferInput<typeof labelSchema> {
}
export type LabelValue = v.InferInput<typeof labelValueSchema>;
export interface LabelValueDefinition extends v.InferInput<typeof labelValueDefinitionSchema> {
}
export interface LabelValueDefinitionStrings extends v.InferInput<typeof labelValueDefinitionStringsSchema> {
}
export interface SelfLabel extends v.InferInput<typeof selfLabelSchema> {
}
export interface SelfLabels extends v.InferInput<typeof selfLabelsSchema> {
}
export {};
//# sourceMappingURL=defs.d.ts.map