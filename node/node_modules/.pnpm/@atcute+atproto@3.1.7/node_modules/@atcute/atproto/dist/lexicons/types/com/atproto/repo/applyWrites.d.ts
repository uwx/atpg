import * as v from '@atcute/lexicons/validations';
import * as ComAtprotoRepoDefs from './defs.js';
declare const _createSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.repo.applyWrites#create">, undefined>;
    collection: v.FormattedStringSchema<"nsid">;
    /**
     * NOTE: maxLength is redundant with record-key format. Keeping it temporarily to ensure backwards compatibility.
     * @maxLength 512
     */
    rkey: v.OptionalSchema<v.SchemaWithConstraint<v.FormattedStringSchema<"record-key">, readonly [v.StringLengthConstraint<0, 512>]>, undefined>;
    value: v.UnknownSchema;
}>;
declare const _createResultSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.repo.applyWrites#createResult">, undefined>;
    cid: v.FormattedStringSchema<"cid">;
    uri: v.FormattedStringSchema<"at-uri">;
    validationStatus: v.OptionalSchema<v.StringSchema<"unknown" | (string & {}) | "valid">, undefined>;
}>;
declare const _deleteSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.repo.applyWrites#delete">, undefined>;
    collection: v.FormattedStringSchema<"nsid">;
    rkey: v.FormattedStringSchema<"record-key">;
}>;
declare const _deleteResultSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.repo.applyWrites#deleteResult">, undefined>;
}>;
declare const _mainSchema: v.XRPCProcedureMetadata<null, {
    type: "lex";
    schema: v.ObjectSchema<{
        /**
         * The handle or DID of the repo (aka, current account).
         */
        repo: v.FormattedStringSchema<"at-identifier">;
        /**
         * If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.
         */
        swapCommit: v.OptionalSchema<v.FormattedStringSchema<"cid">, undefined>;
        /**
         * Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons.
         */
        validate: v.OptionalSchema<v.BooleanSchema, undefined>;
        readonly writes: v.ArraySchema<v.VariantSchema<readonly [createSchema, deleteSchema, updateSchema], true>>;
    }>;
}, {
    type: "lex";
    schema: v.ObjectSchema<{
        readonly commit: v.OptionalSchema<ComAtprotoRepoDefs.commitMetaSchema, undefined>;
        readonly results: v.OptionalSchema<v.ArraySchema<v.VariantSchema<readonly [createResultSchema, deleteResultSchema, updateResultSchema], true>>, undefined>;
    }>;
}, "com.atproto.repo.applyWrites">;
declare const _updateSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.repo.applyWrites#update">, undefined>;
    collection: v.FormattedStringSchema<"nsid">;
    rkey: v.FormattedStringSchema<"record-key">;
    value: v.UnknownSchema;
}>;
declare const _updateResultSchema: v.ObjectSchema<{
    $type: v.OptionalSchema<v.LiteralSchema<"com.atproto.repo.applyWrites#updateResult">, undefined>;
    cid: v.FormattedStringSchema<"cid">;
    uri: v.FormattedStringSchema<"at-uri">;
    validationStatus: v.OptionalSchema<v.StringSchema<"unknown" | (string & {}) | "valid">, undefined>;
}>;
type create$schematype = typeof _createSchema;
type createResult$schematype = typeof _createResultSchema;
type delete$schematype = typeof _deleteSchema;
type deleteResult$schematype = typeof _deleteResultSchema;
type main$schematype = typeof _mainSchema;
type update$schematype = typeof _updateSchema;
type updateResult$schematype = typeof _updateResultSchema;
export interface createSchema extends create$schematype {
}
export interface createResultSchema extends createResult$schematype {
}
export interface deleteSchema extends delete$schematype {
}
export interface deleteResultSchema extends deleteResult$schematype {
}
export interface mainSchema extends main$schematype {
}
export interface updateSchema extends update$schematype {
}
export interface updateResultSchema extends updateResult$schematype {
}
export declare const createSchema: createSchema;
export declare const createResultSchema: createResultSchema;
export declare const deleteSchema: deleteSchema;
export declare const deleteResultSchema: deleteResultSchema;
export declare const mainSchema: mainSchema;
export declare const updateSchema: updateSchema;
export declare const updateResultSchema: updateResultSchema;
export interface Create extends v.InferInput<typeof createSchema> {
}
export interface CreateResult extends v.InferInput<typeof createResultSchema> {
}
export interface Delete extends v.InferInput<typeof deleteSchema> {
}
export interface DeleteResult extends v.InferInput<typeof deleteResultSchema> {
}
export interface Update extends v.InferInput<typeof updateSchema> {
}
export interface UpdateResult extends v.InferInput<typeof updateResultSchema> {
}
export interface $params {
}
export interface $input extends v.InferXRPCBodyInput<mainSchema['input']> {
}
export interface $output extends v.InferXRPCBodyInput<mainSchema['output']> {
}
declare module '@atcute/lexicons/ambient' {
    interface XRPCProcedures {
        'com.atproto.repo.applyWrites': mainSchema;
    }
}
export {};
//# sourceMappingURL=applyWrites.d.ts.map