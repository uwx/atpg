{"version":3,"sources":["/home/runner/work/partykit/partykit/packages/partysocket/dist/chunk-MPYVIZZQ.js","../src/use-handlers.ts","../src/use-socket.ts","../src/use-ws.ts"],"names":["useRef","useEffect","options"],"mappings":"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","file":"/home/runner/work/partykit/partykit/packages/partysocket/dist/chunk-MPYVIZZQ.js","sourcesContent":[null,"import { useEffect, useRef } from \"react\";\n\nimport type WebSocket from \"./ws\";\n\nexport type EventHandlerOptions = {\n  onOpen?: (event: WebSocketEventMap[\"open\"]) => void;\n  onMessage?: (event: WebSocketEventMap[\"message\"]) => void;\n  onClose?: (event: WebSocketEventMap[\"close\"]) => void;\n  onError?: (event: WebSocketEventMap[\"error\"]) => void;\n};\n\n/** Attaches event handlers to a WebSocket in a React Lifecycle-friendly way */\nexport const useAttachWebSocketEventHandlers = (\n  socket: WebSocket,\n  options: EventHandlerOptions\n) => {\n  const handlersRef = useRef(options);\n  handlersRef.current = options;\n\n  useEffect(() => {\n    const onOpen: EventHandlerOptions[\"onOpen\"] = (event) =>\n      handlersRef.current?.onOpen?.(event);\n    const onMessage: EventHandlerOptions[\"onMessage\"] = (event) =>\n      handlersRef.current?.onMessage?.(event);\n    const onClose: EventHandlerOptions[\"onClose\"] = (event) =>\n      handlersRef.current?.onClose?.(event);\n    const onError: EventHandlerOptions[\"onError\"] = (event) =>\n      handlersRef.current?.onError?.(event);\n\n    socket.addEventListener(\"open\", onOpen);\n    socket.addEventListener(\"close\", onClose);\n    socket.addEventListener(\"error\", onError);\n    socket.addEventListener(\"message\", onMessage);\n\n    return () => {\n      socket.removeEventListener(\"open\", onOpen);\n      socket.removeEventListener(\"close\", onClose);\n      socket.removeEventListener(\"error\", onError);\n      socket.removeEventListener(\"message\", onMessage);\n    };\n  }, [socket]);\n};\n","import { useEffect, useMemo, useRef, useState } from \"react\";\n\nimport type WebSocket from \"./ws\";\nimport type { Options } from \"./ws\";\n\n/** When any of the option values are changed, we should reinitialize the socket */\nexport const getOptionsThatShouldCauseRestartWhenChanged = (\n  options: Options\n) => [\n  options.startClosed,\n  options.minUptime,\n  options.maxRetries,\n  options.connectionTimeout,\n  options.maxEnqueuedMessages,\n  options.maxReconnectionDelay,\n  options.minReconnectionDelay,\n  options.reconnectionDelayGrowFactor,\n  options.debug\n];\n\n/**\n * Initializes a PartySocket (or WebSocket) and keeps it stable across renders,\n * but reconnects and updates the reference when any of the connection args change.\n */\nexport function useStableSocket<T extends WebSocket, TOpts extends Options>({\n  options,\n  createSocket,\n  createSocketMemoKey: createOptionsMemoKey\n}: {\n  options: TOpts;\n  createSocket: (options: TOpts) => T;\n  createSocketMemoKey: (options: TOpts) => string;\n}) {\n  // ensure we only reconnect when necessary\n  const shouldReconnect = createOptionsMemoKey(options);\n  const socketOptions = useMemo(() => {\n    return options;\n  }, [shouldReconnect]);\n\n  // this is the socket we return\n  const [socket, setSocket] = useState<T>(() =>\n    // only connect on first mount\n    createSocket({ ...socketOptions, startClosed: true })\n  );\n\n  // keep track of the socket we initialized\n  const socketInitializedRef = useRef<T | null>(null);\n\n  // allow changing the socket factory without reconnecting\n  const createSocketRef = useRef(createSocket);\n  createSocketRef.current = createSocket;\n\n  // finally, initialize the socket\n  useEffect(() => {\n    // we haven't yet restarted the socket\n    if (socketInitializedRef.current === socket) {\n      // create new socket\n      const newSocket = createSocketRef.current({\n        ...socketOptions,\n        // when reconnecting because of options change, we always reconnect\n        // (startClosed only applies to initial mount)\n        startClosed: false\n      });\n\n      // update socket reference (this will cause the effect to run again)\n      setSocket(newSocket);\n    } else {\n      // if this is the first time we are running the hook, connect...\n      if (!socketInitializedRef.current && socketOptions.startClosed !== true) {\n        socket.reconnect();\n      }\n      // track initialized socket so we know not to do it again\n      socketInitializedRef.current = socket;\n      // close the old socket the next time the socket changes or we unmount\n      return () => {\n        socket.close();\n      };\n    }\n  }, [socket, socketOptions]);\n\n  return socket;\n}\n","import { useAttachWebSocketEventHandlers } from \"./use-handlers\";\nimport {\n  getOptionsThatShouldCauseRestartWhenChanged,\n  useStableSocket\n} from \"./use-socket\";\nimport WebSocket from \"./ws\";\n\nimport type { EventHandlerOptions } from \"./use-handlers\";\nimport type { Options, ProtocolsProvider, UrlProvider } from \"./ws\";\n\ntype UseWebSocketOptions = Options & EventHandlerOptions;\n\n// A React hook that wraps PartySocket\nexport default function useWebSocket(\n  url: UrlProvider,\n  protocols?: ProtocolsProvider,\n  options: UseWebSocketOptions = {}\n) {\n  const socket = useStableSocket({\n    options,\n    createSocket: (options) => new WebSocket(url, protocols, options),\n    createSocketMemoKey: (options) =>\n      JSON.stringify([\n        // will reconnect if url or protocols are specified as a string.\n        // if they are functions, the WebSocket will handle reconnection\n        url,\n        protocols,\n        ...getOptionsThatShouldCauseRestartWhenChanged(options)\n      ])\n  });\n\n  useAttachWebSocketEventHandlers(socket, options);\n\n  return socket;\n}\n"]}