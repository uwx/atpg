import * as v from '@atcute/lexicons/validations';
import * as AppBskyUnspeccedDefs from './defs.js';
declare const _mainSchema: v.XRPCQueryMetadata<v.ObjectSchema<{
    /**
     * Filter to posts by the given account. Handles are resolved to DID before query-time.
     */
    author: v.OptionalSchema<v.FormattedStringSchema<"at-identifier">, undefined>;
    /**
     * Optional pagination mechanism; may not necessarily allow scrolling through entire result set.
     */
    cursor: v.OptionalSchema<v.StringSchema<string>, undefined>;
    /**
     * Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization.
     */
    domain: v.OptionalSchema<v.StringSchema<string>, undefined>;
    /**
     * Filter to posts in the given language. Expected to be based on post language field, though server may override language detection.
     */
    lang: v.OptionalSchema<v.FormattedStringSchema<"language">, undefined>;
    /**
     * @minimum 1
     * @maximum 100
     * @default 25
     */
    limit: v.OptionalSchema<v.SchemaWithConstraint<v.IntegerSchema, readonly [v.IntegerRangeConstraint<1, 100>]>, 25>;
    /**
     * Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions.
     */
    mentions: v.OptionalSchema<v.FormattedStringSchema<"at-identifier">, undefined>;
    /**
     * Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended.
     */
    q: v.StringSchema<string>;
    /**
     * Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD).
     */
    since: v.OptionalSchema<v.StringSchema<string>, undefined>;
    /**
     * Specifies the ranking order of results.
     * @default "latest"
     */
    sort: v.OptionalSchema<v.StringSchema<(string & {}) | "latest" | "top">, "latest">;
    /**
     * Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching.
     */
    tag: v.OptionalSchema<v.ArraySchema<v.SchemaWithConstraint<v.StringSchema<string>, readonly [v.StringLengthConstraint<0, 640>, v.StringGraphemesConstraint<0, 64>]>>, undefined>;
    /**
     * Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD).
     */
    until: v.OptionalSchema<v.StringSchema<string>, undefined>;
    /**
     * Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching.
     */
    url: v.OptionalSchema<v.FormattedStringSchema<"uri">, undefined>;
    /**
     * DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries.
     */
    viewer: v.OptionalSchema<v.FormattedStringSchema<"did">, undefined>;
}>, {
    type: "lex";
    schema: v.ObjectSchema<{
        cursor: v.OptionalSchema<v.StringSchema<string>, undefined>;
        /**
         * Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits.
         */
        hitsTotal: v.OptionalSchema<v.IntegerSchema, undefined>;
        readonly posts: v.ArraySchema<AppBskyUnspeccedDefs.skeletonSearchPostSchema>;
    }>;
}, "app.bsky.unspecced.searchPostsSkeleton">;
type main$schematype = typeof _mainSchema;
export interface mainSchema extends main$schematype {
}
export declare const mainSchema: mainSchema;
export interface $params extends v.InferInput<mainSchema['params']> {
}
export interface $output extends v.InferXRPCBodyInput<mainSchema['output']> {
}
declare module '@atcute/lexicons/ambient' {
    interface XRPCQueries {
        'app.bsky.unspecced.searchPostsSkeleton': mainSchema;
    }
}
export {};
//# sourceMappingURL=searchPostsSkeleton.d.ts.map